1 JANE 2
1 MARIA 2
3 PET STE 2
3 JANE MARIA 2
3 JANE MARIANA 2
3 A ZZZ 
0

OUTPUT:
0
1
2
0

1 JANE 2
1 MARIA 2
1 B 2
1 C 2
1 A 2
3 B MARIA 2
0

1 JANE 2
1 MARIA 2
1 B 2
1 C 2
1 A 2
3 B MARIA 2
0

1 C 2
1 B 2
1 A 2
1 G 2
1 H 2
3 C G 2
3 C H 2
3 A I 2
0

output:
1
2
5



BOYS:
0
1 JOSHUA 1
1 PETER 1
3 PET STE 1
0

 /* public Baby successor(String key) { 

    System.out.println("in successor, searching for successor to : " + key);

    Node vPos = find(root, key);
    return vPos == null ? null : successor(vPos);
    //return successor(vPos);
  }

  public Baby predecessor(String key) { 
    Node vPos = find(root, key);
    //return vPos == null ? null : predecessor(vPos);
    return predecessor(vPos);
  }*/

 /* public int countSubMap(String start, String end){

    if(root == null)
      return 0;


    Node leftBound = root, rightBound = root;
    int cutOffBoundLeft = 0, cutOffBoundRight = 0;    

    // Look for node that is smaller than start

    while(leftBound.left != null && leftBound.left.value.babyName.compareTo(start) >= 0){

      leftBound = leftBound.left;

    }

     // Look for node that is bigger than end
    while(rightBound.right != null && rightBound.right.value.babyName.compareTo(end) < 0){

      rightBound = rightBound.right;

    }

    // If still nodes left, cut them of
    if(leftBound.left != null)
      cutOffBoundLeft += size(leftBound.left);

    if(rightBound.right != null)
      cutOffBoundRight = size(rightBound.right);

 //   System.out.println("Leftbound is at " + leftBound.value);
  //  System.out.println("RightBound is at " + rightBound.value);

    // CORNER CASE with only two nodes 
    if(root.left == null){

      /*System.out.println("yes");
      while(leftBound.value.babyName.compareTo(start) >= 0 && leftBound.right != null)
        leftBound = leftBound.right;
      //System.out.println("root left null");

      if(leftBound.value.babyName.compareTo(start) < 0 && leftBound.right != null){
       // System.out.println("start is not in interval");
        leftBound = leftBound.right;
      
        if(leftBound.value.babyName.compareTo(start) < 0){
         // System.out.println("not this time eitehr");
          return 0;
        } else {
          return 1;
        }

      }

    }

    return size(root) - cutOffBoundLeft - cutOffBoundRight;
 
  }*/




  /*
  protected Node delete(Node node, String key) {
    if (node == null)  return node;              // cannot find the item to be deleted

    if (node.value.babyName.equals(key)) {                          // this is the node to be deleted
      if (node.left == null && node.right == null)                   // this is a leaf
        node = null;                                      // simply erase this node
      else if (node.left == null && node.right != null) {   // only one child at right
        Node temp = node;
        node.right.parent = node.parent;
        node = node.right;                                                 // bypass T
        temp = null;
      }
      else if (node.left != null && node.right == null) {    // only one child at left
        Node temp = node;
        node.left.parent = node.parent;
        node = node.left;                                                  // bypass T
        temp = null;
      }
      else {                                 // has two children, find successor
        Baby successorV = successor(node.value.babyName);
        node.value = successorV;         // replace this key with the successor's key
        node.right = delete(node.right, successorV.babyName);      // delete the old successorV
      }
    }
    else if (node.value.babyName.compareTo(key) > 0)                                   // search to the right
      node.right = delete(node.right, key);
    else                                                   // search to the left
      node.left = delete(node.left, key);
    return node;                                          // return the updated BST
  }*/


  /*
  protected Node delete(Node node, String key) {
    if (node == null)  return node;              // cannot find the item to be deleted

    if (node.value.babyName.equals(key)) {                          // this is the node to be deleted
      if (node.left == null && node.right == null)                   // this is a leaf
        node = null;                                      // simply erase this node
      else if (node.left == null && node.right != null) {   // only one child at right
        Node temp = node;
        node.right.parent = node.parent;
        node = node.right;                                                 // bypass T
        temp = null;
      }
      else if (node.left != null && node.right == null) {    // only one child at left
        Node temp = node;
        node.left.parent = node.parent;
        node = node.left;                                                  // bypass T
        temp = null;
      }
      else {                                 // has two children, find successor
        Baby successorV = successor(node.value.babyName);
        node.value = successorV;         // replace this key with the successor's key
        node.right = delete(node.right, successorV.babyName);      // delete the old successorV
      }
    }
    else if (node.value.babyName.compareTo(key) > 0)                                   // search to the right
      node.right = delete(node.right, key);
    else                                                   // search to the left
      node.left = delete(node.left, key);
    return node;                                          // return the updated BST
  }*/
